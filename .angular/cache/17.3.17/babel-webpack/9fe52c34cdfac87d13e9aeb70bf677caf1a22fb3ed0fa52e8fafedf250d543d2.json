{"ast":null,"code":"import { of } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../repositories/local/local-order.repository\";\nimport * as i2 from \"../repositories/firebase/firebase-order.repository\";\nexport let OrderService = /*#__PURE__*/(() => {\n  class OrderService {\n    constructor(localRepo, firebaseRepo) {\n      this.localRepo = localRepo;\n      this.firebaseRepo = firebaseRepo;\n    }\n    createOrder(order) {\n      // 1. Siempre guardar en local primero (Offline First)\n      order.status = 'pending';\n      return this.localRepo.createOrder(order).pipe(switchMap(savedOrder => {\n        // 2. Si hay configuración de Firebase, intentar sincronizar\n        if (environment.useFirebase) {\n          return this.firebaseRepo.createOrder(savedOrder).pipe(map(syncedOrder => {\n            // Si es exitoso, actualizar estado local\n            this.localRepo.updateStatus(savedOrder.id, 'synced');\n            savedOrder.status = 'synced';\n            return savedOrder;\n          }), catchError(err => {\n            console.warn('Sync failed, keeping local order', err);\n            return of(savedOrder);\n          }));\n        }\n        return of(savedOrder);\n      }));\n    }\n    getOrders(userId) {\n      return this.localRepo.getOrders(userId);\n      // Podríamos mezclar con firebase si hay red, pero por consistencia offline leemos local\n    }\n    static {\n      this.ɵfac = function OrderService_Factory(t) {\n        return new (t || OrderService)(i0.ɵɵinject(i1.LocalOrderRepository), i0.ɵɵinject(i2.FirebaseOrderRepository));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: OrderService,\n        factory: OrderService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return OrderService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}